from math import exp
import numpy as np

import pyximport;  # @UnresolvedImport
pyximport.install(setup_args={"include_dirs": np.get_include()}, reload_support=True)  

import demand, util  # @UnresolvedImport


def ex_grid(intensity=0.5, H=9*60, debug=False):
    """
    Problem specification:
    Here we use the same notation as ex1().
    
    p. 50 ~ 51 of Lees-Miller, 2011
    The number of station is change to 24.  
    The distance of each line in grid_network is 800m.
    The fleet size is set at 200 vehicles and the speed of vehicles is 10m/s. So the travel time on each line is 1.33min.
    
    H: time horizon (sec)
    """
    
    # Network
    nS = 24
    ET = [  # edges with travel time (sec)
        ( 0,  1, 80), ( 0, 13, 80), ( 1,  2, 80), ( 2, 15, 80), ( 3, 12, 80),
        ( 4,  3, 80), ( 4, 17, 80), ( 5,  4, 80), ( 5, 14, 80), ( 6,  7, 80),
        ( 6, 21, 80), ( 7,  8, 80), ( 7, 18, 80), ( 8, 23, 80), ( 9, 20, 80),
        (10,  9, 80), (11, 10, 80), (11, 22, 80), (12,  0, 80), (13,  3, 80),
        (13, 17, 80), (14,  2, 80), (15,  5, 80), (15, 19, 80), (16, 12, 80),
        (17,  7, 80), (17, 21, 80), (18,  4, 80), (18, 14, 80), (19, 23, 80),
        (20,  6, 80), (20, 16, 80), (21,  9, 80), (22,  8, 80), (22, 18, 80),
        (23, 11, 80)
    ]
    t = util.build_trip_time_table(nS, ET)
    
    # Vehicles
    nK = 200
    d0 = np.array([(k % nS) for k in range(nK)])
    a0 = np.repeat(0.0, nK)
    
    # Demand
    MODIFIER_CONSIDERING_INTENSITY_AND_MIN = 2035/3600
    nD = int(round(H * intensity * MODIFIER_CONSIDERING_INTENSITY_AND_MIN))
    JAR = [(3600, MODIFIER_CONSIDERING_INTENSITY_AND_MIN * intensity)]
    
    inflow  = [0.05 , 0.05, 0.05, 0.0375, 0.025 , 0.0375, 0.0375, 0.025, 0.0375,
               0.05 , 0.05, 0.05, 0.05  , 0.0375, 0.0375, 0.05  , 0.05  , 0.025,
               0.025, 0.05, 0.05, 0.0375, 0.0375, 0.05]
    outflow = [0.008, 0.008, 0.008, 0.038,  0.15, 0.038, 0.038,  0.15, 0.038,
               0.008, 0.008, 0.008, 0.008, 0.038, 0.038, 0.008, 0.008,  0.15,
               0.15, 0.008, 0.008, 0.038, 0.038, 0.008]
    
    # NOTE Lees-Miller (2011) states that OD matrix is generated by the following
    #   inflow and outflow ratio, but it does not conform to experimental results
    #   Hence, we use the figures in Lees-Miller's GitHub source below (m).
    # m = generate_OD_matrix(nS, inflow, outflow, t, th)
    #
    # From https://github.com/jdleesmiller/si_taxi/ext/si_taxi_test/si_taxi_test.cpp
    #
    m = [[0,0.000574,9.72e-05,0.00125,0.000421,0.000236,4.76e-05,0.00209,0.000253,1.96e-05,4.73e-06,6.22e-06,4.37e-05,0.0026,0.000114,6.86e-05,1.05e-05,0.00464,0.000937,5.21e-05,1.39e-05,0.000562,2.14e-05,8.81e-06],
         [1.23e-05,0,0.000951,0.000499,0.00412,0.00231,1.9e-05,0.000832,0.000101,7.83e-06,4.63e-05,6.09e-05,1.74e-05,4.23e-05,0.00111,0.000672,4.2e-06,0.00185,0.000374,0.00051,5.53e-06,0.000224,0.000209,8.63e-05],
         [1.32e-05,1e-05,0,0.000535,0.00442,0.00247,2.04e-05,0.000892,0.000108,8.39e-06,4.96e-05,6.53e-05,1.87e-05,4.53e-05,0.00119,0.00072,4.5e-06,0.00199,0.000401,0.000546,5.92e-06,0.00024,0.000224,9.25e-05],
         [0.000547,0.000415,7.02e-05,0,0.000304,0.00017,3.44e-05,0.00151,0.000183,1.42e-05,3.41e-06,4.5e-06,0.000774,0.00188,8.2e-05,4.96e-05,7.6e-06,0.00335,0.000677,3.76e-05,1e-05,0.000406,1.55e-05,6.37e-06],
         [2.13e-05,1.61e-05,2.73e-06,0.000863,0,6.63e-06,3.28e-05,0.00144,0.000174,1.35e-05,3.26e-06,4.29e-06,3.01e-05,7.31e-05,7.83e-05,1.93e-06,7.25e-06,0.0032,0.000646,1.46e-06,9.55e-06,0.000388,1.48e-05,6.08e-06],
         [1.39e-05,1.06e-05,4.38e-05,0.000564,0.00466,0,2.15e-05,0.000941,0.000114,8.85e-06,2.13e-06,2.81e-06,1.97e-05,4.78e-05,0.00126,3.09e-05,4.74e-06,0.00209,0.000423,2.35e-05,6.25e-06,0.000254,9.65e-06,3.97e-06],
         [2.81e-06,2.13e-06,8.85e-06,0.000114,0.000941,2.15e-05,0,0.00466,0.000564,4.38e-05,1.06e-05,1.39e-05,3.97e-06,9.65e-06,0.000254,6.25e-06,2.35e-05,0.000423,0.00209,4.74e-06,3.09e-05,0.00126,4.78e-05,1.97e-05],
         [4.29e-06,3.26e-06,1.35e-05,0.000174,0.00144,3.28e-05,6.63e-06,0,0.000863,2.73e-06,1.61e-05,2.13e-05,6.08e-06,1.48e-05,0.000388,9.55e-06,1.46e-06,0.000646,0.0032,7.25e-06,1.93e-06,7.83e-05,7.31e-05,3.01e-05],
         [4.5e-06,3.41e-06,1.42e-05,0.000183,0.00151,3.44e-05,0.00017,0.000304,0,7.02e-05,0.000415,0.000547,6.37e-06,1.55e-05,0.000406,1e-05,3.76e-05,0.000677,0.00335,7.6e-06,4.96e-05,8.2e-05,0.00188,0.000774],
         [6.53e-05,4.96e-05,8.39e-06,0.000108,0.000892,2.04e-05,0.00247,0.00442,0.000535,0,1e-05,1.32e-05,9.25e-05,0.000224,0.00024,5.92e-06,0.000546,0.000401,0.00199,4.5e-06,0.00072,0.00119,4.53e-05,1.87e-05],
         [6.09e-05,4.63e-05,7.83e-06,0.000101,0.000832,1.9e-05,0.00231,0.00412,0.000499,0.000951,0,1.23e-05,8.63e-05,0.000209,0.000224,5.53e-06,0.00051,0.000374,0.00185,4.2e-06,0.000672,0.00111,4.23e-05,1.74e-05],
         [6.22e-06,4.73e-06,1.96e-05,0.000253,0.00209,4.76e-05,0.000236,0.000421,0.00125,9.72e-05,0.000574,0,8.81e-06,2.14e-05,0.000562,1.39e-05,5.21e-05,0.000937,0.00464,1.05e-05,6.86e-05,0.000114,0.0026,4.37e-05],
         [0.00072,0.000546,9.25e-05,0.00119,0.000401,0.000224,4.53e-05,0.00199,0.00024,1.87e-05,4.5e-06,5.92e-06,0,0.00247,0.000108,6.53e-05,1e-05,0.00442,0.000892,4.96e-05,1.32e-05,0.000535,2.04e-05,8.39e-06],
         [3.09e-05,2.35e-05,3.97e-06,0.00126,0.000423,9.65e-06,4.78e-05,0.00209,0.000254,1.97e-05,4.74e-06,6.25e-06,4.38e-05,0,0.000114,2.81e-06,1.06e-05,0.00466,0.000941,2.13e-06,1.39e-05,0.000564,2.15e-05,8.85e-06],
         [1e-05,7.6e-06,0.000774,0.000406,0.00335,0.00188,1.55e-05,0.000677,8.2e-05,6.37e-06,3.76e-05,4.96e-05,1.42e-05,3.44e-05,0,0.000547,3.41e-06,0.00151,0.000304,0.000415,4.5e-06,0.000183,0.00017,7.02e-05],
         [1.39e-05,1.05e-05,4.37e-05,0.000562,0.00464,0.0026,2.14e-05,0.000937,0.000114,8.81e-06,5.21e-05,6.86e-05,1.96e-05,4.76e-05,0.00125,0,4.73e-06,0.00209,0.000421,0.000574,6.22e-06,0.000253,0.000236,9.72e-05],
         [0.000672,0.00051,8.63e-05,0.00111,0.000374,0.000209,4.23e-05,0.00185,0.000224,1.74e-05,4.2e-06,5.53e-06,0.000951,0.00231,0.000101,6.09e-05,0,0.00412,0.000832,4.63e-05,1.23e-05,0.000499,1.9e-05,7.83e-06],
         [1.93e-06,1.46e-06,6.08e-06,7.83e-05,0.000646,1.48e-05,7.31e-05,0.0032,0.000388,3.01e-05,7.25e-06,9.55e-06,2.73e-06,6.63e-06,0.000174,4.29e-06,1.61e-05,0,0.00144,3.26e-06,2.13e-05,0.000863,3.28e-05,1.35e-05],
         [9.55e-06,7.25e-06,3.01e-05,0.000388,0.0032,7.31e-05,1.48e-05,0.000646,7.83e-05,6.08e-06,1.46e-06,1.93e-06,1.35e-05,3.28e-05,0.000863,2.13e-05,3.26e-06,0.00144,0,1.61e-05,4.29e-06,0.000174,6.63e-06,2.73e-06],
         [5.53e-06,4.2e-06,1.74e-05,0.000224,0.00185,4.23e-05,0.000209,0.000374,0.00111,8.63e-05,0.00051,0.000672,7.83e-06,1.9e-05,0.000499,1.23e-05,4.63e-05,0.000832,0.00412,0,6.09e-05,0.000101,0.00231,0.000951],
         [6.86e-05,5.21e-05,8.81e-06,0.000114,0.000937,2.14e-05,0.0026,0.00464,0.000562,4.37e-05,1.05e-05,1.39e-05,9.72e-05,0.000236,0.000253,6.22e-06,0.000574,0.000421,0.00209,4.73e-06,0,0.00125,4.76e-05,1.96e-05],
         [4.96e-05,3.76e-05,6.37e-06,8.2e-05,0.000677,1.55e-05,0.00188,0.00335,0.000406,0.000774,7.6e-06,1e-05,7.02e-05,0.00017,0.000183,4.5e-06,0.000415,0.000304,0.00151,3.41e-06,0.000547,0,3.44e-05,1.42e-05],
         [6.25e-06,4.74e-06,1.97e-05,0.000254,0.00209,4.78e-05,9.65e-06,0.000423,0.00126,3.97e-06,2.35e-05,3.09e-05,8.85e-06,2.15e-05,0.000564,1.39e-05,2.13e-06,0.000941,0.00466,1.06e-05,2.81e-06,0.000114,0,4.38e-05],
         [5.92e-06,4.5e-06,1.87e-05,0.00024,0.00199,4.53e-05,0.000224,0.000401,0.00119,9.25e-05,0.000546,0.00072,8.39e-06,2.04e-05,0.000535,1.32e-05,4.96e-05,0.000892,0.00442,1e-05,6.53e-05,0.000108,0.00247,0]]
    
    assert all(m[i][i] == 0 for i in range(len(m)))
    ODM = demand.od_matrix(list(range(len(m))), m, JAR)
    e, u, v = zip(*[ODM.next_arrival() for _ in range(nD)])
    e, u, v = np.array(e, float), np.array(u, int), np.array(v, int)  # to np.array
    
    # Demand validation
    if debug:
        N = [0] * nS
        for i in u:
            N[i] += 1
        for i in range(nS):
            print('%.03f %.03f %.03f' % (sum(m[i]) / sum(sum(mi) for mi in m), inflow[i], N[i] / nD))
        print
        N = [0] * nS
        for i in v:
            N[i] += 1
        for i in range(nS):
            print('%.03f %.03f' % (outflow[i], N[i] / nD))
    
    return nS, t, nK, d0, a0, nD, e, u, v, ODM


def generate_OD_matrix(nS, inflow, outflow, t, th=0.01):
    """
    Generate OD matrix based on standard gravity model (Chakroborty & Das, 2003).
      Numerical calculation has been done based on �엫�슜�깮 (2010).
    
    nS: number of stations
    inflow[k]: ratio of input flow of station k
    outflow[k]: ratio of out flow from station k
    t[k1][k2]: time to travel from k1 to k2
    th (theta): model parameter
    
    References:
      - Chakroborty and Das (2003). Principles of transportation
        engineering. Prentice Hall of India.
      - �엫�슜�깮 (2010). 洹좏삎 �넻�뻾遺꾪룷紐⑦삎�뿰援�, ���븳援먰넻�븰�쉶吏�, 28沅�, 6�샇.
    """
    
    EPSILON = 0.00001
    a, b, a0, b0 = [1] * nS, [1] * nS, [1e400] * nS, [1e400] * nS
    
    for i in range(nS):
        sum_A = 0
        for j in range(nS):
            if i != j:
                sum_A += b[j] * outflow[j] * exp(-th * t[i][j])
        a[i] = 1/sum_A
    
    for j in range(nS):
        b_sum = 0
        for i in range(nS):
            if i != j:
                b_sum += a[i] * inflow[i] * exp(-th * t[i][j])
        b[j] = (b_sum)**-1 
    
    for i in range(nS):
        a_sum = 0
        for j in range(nS):
            if j != i:
                a_sum += b[j] * outflow[j] * exp(-th * t[i][j])
        a[i] = (a_sum)**-1
    
    while max(abs(a[i] - a0[i]) for i in range(nS)) > EPSILON or \
          max(abs(b[j] - b0[j]) for j in range(nS)) > EPSILON:
        a, b, a0, b0 = a0, b0, a, b
        for j in range(nS):
            b_sum = 0
            for i in range(nS):
                if i != j:
                    b_sum += a0[i] * inflow[i] * exp(-th * t[i][j])
            b[j] = (b_sum)**-1 
        for i in range(nS):
            a_sum = 0
            for j in range(nS):
                if j != i:
                    a_sum += b[j] * outflow[j] * exp(-th * t[i][j])
            a[i] = (a_sum)**-1        
    
    m = [[(x * a[i] * y * b[j] * exp(-th*t[i][j]) if i != j else 0) for (j, y) in enumerate(outflow)]
                                                    for (i, x) in enumerate(inflow)]

    return m


if __name__ == '__main__':
    nS, t, nK, d0, a0, nD, e, u, v, ODM = ex_grid(0.5, 100 * 60 * 60, True)
    print(d0)
    print(a0)
    print(e)
    print(u)
    print(v)
    print('nD =', nD)
